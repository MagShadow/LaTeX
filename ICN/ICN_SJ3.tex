\documentclass[a4paper,12pt,notitlepage]{article}
\usepackage{CJKutf8}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{graphicx}

\begin{CJK*}{UTF8}{gbsn}
\begin{document}

\title{计算机网络概论第三次上机报告}
\author{秦光辉\ 1500011398}
\maketitle

\section{路由表数据结构-AVL平衡二叉树}

	路由表是一个需要保证可以快速检索, 又经常需要添加项和删除项的结构. 如果使用哈希表结构, 由于对dst的取值范围一无所知, 我找不到合适的函数. 如果使用最优二叉树处理, 在路由表非常大的时候, 每次添加或者删除都会有很大的运算开销, 很不划算. 我采用了AVL平衡二叉树的方法构造路由表. \\
	
	树bintree是一棵二叉树, 树中存有目的地址, 掩码和下一跳地址. 每次需要添加表项的时候, 可以调用add函数. 每次需要取走元素的时候, 可以调用getNextHop函数. getNextHop函数返回一个bool值, 当检索失败的时候, 返回0, 否则返回1. 树中RR, LL, RL, LR平衡二叉树的调整函数. \\
	
	这样可以使得添加元素和取出元素的速度都比较快. 题中没有给删除表项的接口, 我也没有写删除函数. 
	
\section{初始化函数}

	初始化函数已经写在了类中, 并不需要单独实现. 

\section{添加函数}

	直接调用bintree的add函数即可.
	
\section{接收函数}

	接收报文的时候, 应该把char *pBuffer转换成无符号类型, 这样可以避免编译器在编译的时候自动进行符号位的填充. \\
	
	首先可以用大端小端转换的方法把IPv4报头中的各个元素提取出来, 其中有用的信息有IHL, TTL, Dst等. \\
	
	由于题中已经告诉我们, IPv4的报头是正确的, 我们无须验证其正确性. \\
	
	TTL如果为0, 说明这个IPv4包应该已经达到寿命极限, 不能继续传递, 应该舍弃. 应该报错并返回1. \\
	
	如果Dst和本机IP一致, 这个时候应该把报文转给自己的上层接收. 这个函数应该在检查TTL之前, 因为TTL == 0的包应该还能被主机接收. \\
	
	如果地址不是本机, 可以调用二叉树的get函数, 找其下一跳地址. 如果没有找到, 由于路由表没有default路径, 所以必须抛弃该包, 并且向服务器报告一个错误. \\	
	
	TTL如果不是0 ,且地址不是本机, 则应该把其TTL减一, 然后转发. 由于TTL的变化, 必须重新计算其校验和. \\
	
	把Sum设置成一个32位的无符号类型(避免溢出), 把数据报文拆分成16位一组, 不断累加至Sum. 如果报头字节数为奇数(利用上文算出的THL), 则最后一位应该单独相加. 这些数据求和之后, 再将Sum反复折叠求和, 直到Sum 16位以上的高位全部为0. 将Sum取反, 然后写入需要转发的包中. \\

	把报文转到下层, 返回0, 表示顺利结束.

\end{CJK*}
\end{document}