% homework
% 20161121
% by hiaoxui

\documentclass[a4paper, 12pt, notitlepage]{article}

\usepackage{CJKutf8}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{float}

\setlength{\parindent}{2em} 

\begin{CJK*}{UTF8}{gbsn}
\begin{document}

\title{第五次OS作业}
\author{秦光辉\ 1500011398}
\maketitle

\section{内存管理的功能}

\subsection{}

	内存空间的管理, 分配与回收. 记录内存的使用情况, 设置相应的内存分配表. 负责内存空间划分. \\
	
\subsection{}

	存储共享, 两个或多个进程共用内存中 相同区域. \\

\subsection{}
	
	存储保护与安全. 为多个程序共享内存提供保障, 使在内存中的各道程序, 只能访问它自己的区域, 避免各道程序间相互干拢, 特别是当一道程序发生错误时, 不致于影响其他程序的运行. 保证保护系统程序区不被用户侵犯, 不允许用户程序读写不属于自己地址空间的数据. \\
	
\subsection{}
	
	内存扩充, 通过虚拟内存实现. 用户在编制程序时, 不应该受内存容量限制, 所以要采用一定技术来"扩充"内存的容量, 使用户得到比实际内存容量大的多的内存空间. \\

\subsection{}
	
	地址映射. 在逻辑地址和物理地址之间映射, 
	
\section{解释逻辑地址, 物理地址, 地址映射, 并举例说明}
	
\subsection{}

	虚拟地址: 用户的程序经过汇编或编译后形成目标代码, 目标代码通常采用相对地址的形式, 其首地址为0, 其余指令中的地址都相对于首地址而编址. \\
	
	一个用户作业的目标程序的逻辑地址集合成为该作业的逻辑地址空间. \\
	
\begin{lstlisting}[frame=shadowbox, numbers=left, language=C]
int x = 1;
int y = x + 1;
\end{lstlisting}

	系统在执行上述代码时, 会把x和y两个变量放到栈中, 其在内存中的逻辑地址可能是0和1, 这是变量在程序中的地址, 内存不能直接识别. 

\subsection{}
	
	物理地址是内存中存储单元的实际地址, 可直接寻址. \\
	
	物理地址的总体构成了用户程序实际运行的物理地址空间. \\
	
	在上述代码中, x和y分别在内存中占有4个字节的空间, 其真实所在的地址即为其物理地址. 

\subsection{}
	
	为了保证CPU执行指令时可正确访问存储单元, 需将用户程序中的逻辑地址转换为运行时由机器直接寻址的物理地址, 这一过程称为地址映射. \\
	
	当程序装入内存时, 操作系统要为该程序分配一个合适的内存空间, 由于程序的逻辑地址与分配到内存物理地址不一致, 而CPU执行指令时, 是按物理地址进行的, 所以要进行地址转换. \\
	
	比如在上述例子中, 内存管理可以识别两个逻辑地址, 并根据两个逻辑地址找到其对应的绝对地址. 

\section{在可变分区的管理方式下, 什么是碎片? 如何解决碎片的问题?}

	经过一段时间的分配回收后, 内存中存在很多很小的空闲块. 它们每一个都很小, 不足以满足分配要求;但其总和满足分配要求. 这些空闲块被称为碎片, 造成了存储资源的浪费. \\
	
	碎片解决方案: \\
	
	紧凑技术( 拚接技术, 紧缩技术, 紧致技术, 浮动技术, 搬家技术 ): 通过在内存移动程序, 将所有小的空闲区域合并为大的空闲区域. \\
	
	拚接时机: 当回收某个占用区时, 若没有邻接空闲区但内存中有其他空闲区时, 马上拼接. \\
	
	当需要为新程序分配内存空间, 但在内存中找不到足够容纳该程序的空闲区, 而所有空闲区的总容量却能满足程序需求量时, 再进行拼接. \\

\section{用可变分区方式管理主存时, 假定主存中按地址顺序依次有五个空闲区, 空闲区的大小依次为32K, 10K, 5K, 228K, 100K. 现有五个程序J1, J2, J3, J4和J5. 它们各需主存1K, 10K, 108K, 28K, 115K. 若采用最先适应分配法能把这五个程序按照J1~J5的次序全部装入主存吗?按照什么次序可以时主存空间利用率最高?}

\begin{enumerate}
	\item J1占用第一个空闲区, 第一个空闲区被分割成为1K和31K, 其中31K空闲. 
	\item J2占用第一个空闲区, 第一个空闲区被分割成为10K和21K, 其中21K空闲. 
	\item J3占用第四个空闲区, 第一个空闲区被分割成为108K和110K, 其中110K空闲. 
	\item J4占用第四个空闲区, 第一个空闲区被分割成为28K和82K, 其中82K空闲. 
	\item J5无法装入. 
\end{enumerate}

	最佳次序为: J1, J4, J2, J3, J5. 分配之后, 第一个空闲区剩余3K, 第二个空闲区被用完, 第三个空闲区剩余5K, 第四个空闲区剩余5K, 第五个空闲区剩余100K. 

\section{解释页式(段式)存储管理中为什么要设置页(段)表和快表, 简述页式(段式)地址转换过程}

\subsection{页式存储}

	页表的用途是记录程序页面和主存对应块的对照表, 能把页面映射为页框. 每一栏指明程序中的一个页面和分得的块的对应关系. \\
	
	页表控制寄存器可以保存正在运行进程的页表所在内存的首地址, 当进程被调度程序选中的时候, 系统将页表首地址从PCB中去除送入寄存器. 同时系统将页表成都从PCB中取出, 送入寄存器. \\
	
	页表指出了程序逻辑地址中页号和所占用的主存块号之间的对应关系, 页表长度由程序拥有的页面数决定. 每执行一条指令, 按照逻辑地址中的页号查页表. 如果页表中无此号, 则产生"地址错"的中断事件. 否则按照计算公式转换成相应的主存物理地址. \\
	
	物理地址 = 内存块号 * 块长 + 页内地址 \\
	
	对给定的逻辑地址进行读写的时候, 必须访问主存两次, 延长了指令的执行周期, 降低了执行速度. 所以有必要引入快表. 
	
	快表: 增加一组告诉寄存器保存页表, 可以加速访问过程, 但是有巨大的硬件开销. 可能是联想寄存器, 可能是TLB. \\

	快表存放了当前访问最频繁的少数页面的页号, 快表中登记了页表中页号和主存块号的对应关系. 当需要访问的时候, 地址映射首先在快表中搜索. 如果快表中有, 则拼接地址, 形成物理地址. 否则依然在内存中寻找页表. 
	
\subsection{段式存储管理}

	段表用于记录用户程序的逻辑段与内存物理段之间的对应关系. 段表包含逻辑段号, 物理段首(地)址和物理段长度. \\
	
	段式存储的快表介质为高速缓冲存储器, 介于内存和寄存器之间, 可以保存正在运行进程的段表的子集, 便于高速存取. \\
	
	地址转换过程: 
	
\begin{enumerate}
	\item 当某程序开始执行的时候, 系统首先把程序的段表始址访放入段表始址寄存器. 
	\item 通过访问段表始址寄存器, 得到段表始址而可以开始访问段表. 
	\item 由逻辑地址中的段号S为索引, 检查段表. 
	\item 从段表相应表目中查出该段在内存的起始地址, 和段内地址D相加, 得到实际内存地址. 
\end{enumerate}	
	
	如果使用快表: 
	
\begin{enumerate}
	\item 系统根据逻辑地址中的段号S查找快表
	\item 若在快表中找到该段号, 则根据快表内容比较逻辑地址中的段内地址是否超过段长
	\begin{enumerate}
		\item 如果超过, 则发出越界中断. 
		\item 否则根据快表中的信息合成物理地址, 停止检查内存段表地址的工作
	\end{enumerate}
\end{enumerate}
	
\section{ }

	有一操作系统采用段式存储管理方案, 用户区内存为512k, 分配时截取空闲块的前半部分(小地址部分). 初始时内存全部空闲. 系统执行如下申请, 释放操作序列. \\
	
	申请300k, 申请100k, 释放300k, 申请150k, 申请50k, 释放100k \\
	
\subsection{若采用首先适应算法, 空闲块表中有哪些空块?(指出大小, 地址)}

\begin{itemize}
	\item 512k 空闲
	\item 300k占用, 212k空闲
	\item 300k占用, 100k占用, 112k空闲
	\item 300k空闲, 100k占用, 112k空闲
	\item 150k占用, 150k空闲, 100k占用, 112k空闲
	\item 150k占用, 150k占用, 100k空闲, 100k占用, 112k空闲
	\item 150k占用, 50k占用, 312k空闲
\end{itemize}

	内存中201k - 512k有312k空闲. 

\subsection{若采用首佳适应算法, 空闲块表中有哪些空块?(指出大小, 地址)}

\begin{itemize}
	\item 512k 空闲
	\item 300k占用, 212k空闲
	\item 300k占用, 100k占用, 112k空闲
	\item 300k空闲, 100k占用, 112k空闲
	\item 150k占用, 150k空闲, 100k占用, 112k空闲
	\item 150k占用, 150k空闲, 100k占用, 50k占用, 62k空闲
	\item 150k占用, 250k空闲, 50k占用, 62k空闲
\end{itemize}

	内存中151k - 400k有250k空闲区域, 451k - 512k有62k空闲

\subsection{若随后又申请80k, 空闲块表中有哪些空块?指出大小, 地址)}

	对于首先适应算法, 有
	
\begin{itemize}
	\item 512k 空闲
	\item 300k占用, 212k空闲
	\item 300k占用, 100k占用, 112k空闲
	\item 300k空闲, 100k占用, 112k空闲
	\item 150k占用, 150k空闲, 100k占用, 112k空闲
	\item 150k占用, 150k占用, 100k空闲, 100k占用, 112k空闲
	\item 150k占用, 50k占用, 312k空闲
	\item 150k占用, 50k占用, 80k占用, 232k空闲
\end{itemize}

	内存中281k - 512k有232k空闲. \\
	
	对于首佳适应算法, 有
	
\begin{itemize}
	\item 512k 空闲
	\item 300k占用, 212k空闲
	\item 300k占用, 100k占用, 112k空闲
	\item 300k空闲, 100k占用, 112k空闲
	\item 150k占用, 150k空闲, 100k占用, 112k空闲
	\item 150k占用, 150k空闲, 100k占用, 50k占用, 62k空闲
	\item 150k占用, 250k空闲, 50k占用, 62k空闲
	\item 150k占用, 80k占用, 170k空闲, 50k占用, 62k空闲
\end{itemize}

	内存中231k - 400k有170k空闲区域, 451k - 512k有62k空闲

\section{操作系统的存储管理功能目标是什么? 段页式管理是如何实现这些目标的? }

\subsection{内存空间的管理, 分配与回收}
	
	段页式管理有一个内存分配表, 指出了内存中哪些已经分配, 哪些尚未分配, 当前剩余空闲部分等. \\
	
	用页式来分配和管理内存空间, 即把内存划分为若干大小相等的页面. 分配时, 不再为每一段分配一个连续的主存空间, 而是把每一段分成若干页面, 从而把每一段信息分页存放. \\
	
	程序结束的时候, 回收它的内存空间, 根据归还的块号计算出该块在位视图中对应的位置, 将占用标志修改为0, 再将回收的块数加入到空闲块数中. \\
	
\subsection{存储共享}
	
	对于段页式式存储系统而言, 可以按段为单位来进行共享, 包括通过动态链接进行代码共享. \\
	
	针对代码的共享, 所有共享函数段在所有作业的逻辑地址空间中拥有同样的段号. \\
	
	通过不同作业段表中的项指向同一个段基址来实现, 几道作业共享的例程可以放在一个段中, 让各道作业的共享部分有相同的基址/限长即可. \\
	
\subsection{存储保护与安全}

	地址越界保护法: 通过比较段表始址寄存器和段表长度寄存器中的内容实现保护. \\
	
	存取权控制保护法: 在段表中设有“存取权”一项, 实现对程序的访问权限的必要限制. \\
	
\subsection{内存“扩充”}

	可以通过覆盖技术, 交换技术, 或者虚拟内存实现. 
	
\subsection{地址映射}

	段表: 记录了每一段的页表起始地址和页表长度 , 而不是该段所在内存分区的起始地址. \\
	
	页表 : 记录了逻辑页面号与物理页面号之间的对应关系. (每一段有一个, 一个程序可能有多个页表) \\
	
	段页式存储为每一个装入内存的程序建立一张段表, 每一段建立一张页表, 段表长度由程序分段的个数决定, 而段表中每一表目指出本段的逻辑页号和主存块号的对应关系. \\
	
	执行指令时, 根据逻辑地址中的段号查段表, 得到该段的页表始址, 然后根据页号查页表, 得到主存块号. 由主存块号与逻辑地址中的页内地址形成可访问的绝对地址. 若逻辑地址中的段号超出段表中的最大段号或页号超出该段页表中的最大页号, 形成“地址越界”中断. 
	
\section{为何说段页式管理时虚拟地址仍是二维的?}

	段页式存储有一个段表, 其段表的划分和进程逻辑一致, 按照逻辑单元划分, 如: 主程序, 函数, 全局变量, 栈, 符号表等. 	这些逻辑单元具有独立性. 每个段内建立一个页表, 段内按照页表进行内存管理. 而页表是连续的线性空间, 没有二维结构. 这样段页式存储就可以看做一个二维结构. 
	

\section{为何要引入虚拟存储器? 叙述虚拟段页式管理方案的基本思想}

	内存中可能会遇到两个问题: 
	
\begin{enumerate}
	\item 程序大于内存
	\item 程序暂时不执行或运行完是否还要占用内存
\end{enumerate}

	内存不够用的时候, 可以使用覆盖技术和交换技术, 但是覆盖技术需要程序员自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担. 交换技术以进程作为交换的单位, 需要把进程的整个地址空间都换进换出, 增加了处理器的开销. \\
	
	所以我们引入了虚拟存储器. \\
	
	虚拟段页式管理是虚拟页式和虚拟段式存储管理的结合. \\
	
	虚拟段页式管理存储管理的分配单位是段, 页. 逻辑地址的组成是段号, 页号, 页内偏移地址. 和虚拟页式存储和虚拟段式存储相比, 虚拟段页式存储在数据结构上有所变化. 段表至少包含这个段是否在主存的信息, 以及该段页表的起始地址. 页表包含该页是否在主存(中断位)的信息, 对应主存块号. 在地址变换的时候, 先查段表, 再查该段的页表. 可能会触发缺段中断和缺页中断. 

\section{叙述缺页中断的处理流程}

\begin{enumerate}
	\item 阻塞请求缺页的进程
	\item 根据页面号搜索外页表, 找到存放此页的物理磁盘
	\item 查看主存是否有空闲页框, 如有则可以找出一个空闲页框, 修改主存管理表和相应页表项内容, 转到6
	\item 如主存中无空闲页框, 按替换算法选择一个淘汰页面, 淘汰页面被写过或修改过吗?若未则转6, 否则转5
	\item 若淘汰页面被写过或修改过, 那么把淘汰页的内容写回辅存
	\item 按照该页在辅存储器中的地址把此页面调入, 同时修改进程页表相应项;返回用户进程, 重新执行被中断的指令
	\item 返回进程中断点, 重新启动被中断的指令
\end{enumerate}

\section{有一虚拟存储系统, 分配给某进程3页内存, 开始时内存为空, 页面访问序列如下: }

	6, 5, 4, 3, 2, 1, 5, 4, 3, 6, 5, 4, 3, 2, 1, 6, 5 \\
	
	若采用FIFO, LRU, OPT, LFU, 缺页次数为多少?(该题假定此序列在LFU的周期内, 且单位时间读取1页进行计算) \\
		
\subsection{FIFO}

	页面调用过程如下: 

\begin{table}[H]
\centering

	\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		\# 1 & 6 & 5 & 4 & 3 & 2 & 1 & 5 & 4 & 3 & 6 & 5 & 4 & 3 & 2 & 1 & 6 & 5 \\
		\hline
		\# 2 &   & 6 & 5 & 4 & 3 & 2 & 1 & 5 & 4 & 3 & 6 & 5 & 4 & 3 & 2 & 1 & 6 \\
		\hline
		\# 3 &   &   & 6 & 5 & 4 & 3 & 2 & 1 & 5 & 4 & 3 & 6 & 5 & 4 & 3 & 2 & 1 \\
		\hline
		缺页 & y & y & y & y & y & y & y & y & y & y & y & y & y & y & y & y & y \\
		\hline		
	\end{tabular}

\end{table}

	缺页17次. 
	
\subsection{LRU}
		
\begin{table}[H]
\centering

	\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		\# 1 & 6 & 6 & 6 & 5 & 4 & 3 & 2 & 1 & 5 & 4 & 3 & 6 & 5 & 4 & 3 & 2 & 1 \\
		\hline
		\# 2 &   & 5 & 5 & 4 & 3 & 2 & 1 & 5 & 4 & 3 & 6 & 5 & 4 & 3 & 2 & 1 & 6 \\
		\hline
		\# 3 &   &   & 4 & 3 & 2 & 1 & 5 & 4 & 3 & 6 & 5 & 4 & 3 & 2 & 1 & 6 & 5 \\
		\hline
		缺页 & y & y & y & y & y & y & y & y & y & y & y & y & y & y & y & y & y \\
		\hline		
	\end{tabular}

\end{table}

	缺页17次. 
	
\subsection{OPT}		
	
\begin{table}[H]
\centering

	\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		\# 1 & 6 & 6 & 6 & 3 & 2 & 1 & 1 & 1 & 3 & 6 & 6 & 6 & 6 & 6 & 6 & 6 & 6 \\
		\hline
		\# 2 &   & 5 & 5 & 5 & 5 & 5 & 5 & 5 & 5 & 5 & 5 & 5 & 5 & 5 & 5 & 5 & 5 \\
		\hline
		\# 3 &   &   & 4 & 4 & 4 & 4 & 4 & 4 & 4 & 4 & 4 & 4 & 3 & 2 & 1 & 1 & 1 \\
		\hline
		缺页 & y & y & y & y & y & y & n & n & y & y & n & n & y & y & y & n & n \\
		\hline	
	\end{tabular}

\end{table}

	缺页11次. 
	
\subsection{LFU}
		
\begin{table}[H]
\centering

	\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		\# 1 & 6 & 6 & 6 & 3 & 3 & 3 & 5 & 5 & 5 & 6 & 5 & 5 & 5 & 2 & 1 & 6 & 6 \\
		\hline
		\# 2 &   & 5 & 5 & 5 & 2 & 2 & 2 & 4 & 4 & 4 & 6 & 6 & 3 & 3 & 3 & 3 & 3 \\
		\hline
		\# 3 &   &   & 4 & 4 & 4 & 1 & 1 & 1 & 3 & 3 & 3 & 4 & 4 & 4 & 4 & 4 & 5 \\
		\hline
		缺页 & y & y & y & y & y & y & y & y & y & y & y & y & y & y & y & y & y \\
		\hline	
	\end{tabular}

\end{table}

	缺页17次. 

\section{比较各种存储管理方式的特征(包括主存空间的分配方式, 是否要硬件地址转换机构作支撑, 适合单道或多道系统等), 重定位方式, 地址转换的实现(操作系统和硬件怎样配合), 存储保护的实现(操作系统和硬件各自做些什么工作)}

\subsection{单一用户存储}

	主存分配方式: 每次从内存用户区固定地址开始连续完整存放;从装入一直到执行完毕, 程序单独占据整个用户区内存, 然后退出. \\
	
	硬件地址转换: 无需硬件地址变换机构支持. \\
	
	适合系统: 只适合单道处理系统. \\
	
	重定位方式: 静态或动态. \\
	
	地址转换过程: 多采用静态重定位, 程序执行前由装入程序完成逻辑地址到物理地址的转换工作. \\
	
	也可动态重定位, 程序执行过程中, 在CPU访问主存前, 把要访问的程序和数据的逻辑地址转换到物理地址. \\
	
	存储保护: 无 \\
	
	效率非常低, 不灵活. 

\subsection{分区管理-固定分区管理}

	主存分配方式: 把内存分为一些大小相等或不等的分区(partition), 每个应用进程占用一个或几个分区. 操作系统占用其中一个分区. \\
	
	硬件地址转换: 不必需. \\
	
	适合系统: 多道处理系统. \\
	
	重定位方式: 动态或静态 \\
	
	地址转换过程: 根据基地址生成物理地址. 静态由软件完成;动态可由硬件提供基地址寄存器帮助转换 \\
	
	存储保护: 通过界限寄存器(硬件)或保护键(软件)的相应判断, 产生越界中断或者保护性中断(硬件). \\

\subsection{分区管理-可变分区管理}

	主存分配方式: 在装入程序时从空闲区域中划分 \\
	
	硬件地址转换: 不必需 \\
	
	适合系统: 多道处理系统. \\
	
	重定位方式: 动态 \\
	
	地址转换过程: 根据基地址生成物理地址. 可由硬件提供基地址寄存器帮助转换 \\
	
	存储保护: 通过界限寄存器(硬件)或保护键(软件)的相应判断, 产生越界中断或者保护性中断(硬件). \\

\subsection{页式存储管理}

	主存分配方式: 以页面为单位, 按用户程序需求的页数分配, 分配空间不一定连续 \\
	
	硬件地址转换: 需要页表始址寄存器和长度寄存器, 也可以增加快表 \\
	
	适合系统: 多道处理系统. \\
	
	重定位方式: 动态 \\
	
	地址转换过程: 把逻辑地址分为页号和页内地址, 与页表长度寄存器比较, 检查越界, 根据页表始址寄存器得到页表首地址, 根据逻辑页号找到内存块号, 并且与页内地址拼成物理地址. 可以用快表来实现加速. (硬件) \\
	
	存储保护: 保护键(软件)或扩充页表, 增加存取控制项(硬件) \\

\subsection{段式存储管理}

	主存分配方式: 以段为单位, 为每一个逻辑段分配连续的内存空间 \\
	
	硬件地址转换: 需要段表始址寄存器和长度寄存器, 也可以增加快表 \\
	
	适合系统: 多道处理系统. \\
	
	重定位方式: 动态 \\
	
	地址转换过程: 把逻辑地址分为段号和段内地址, 与段表长度寄存器比较, 检查越界, 根据段表始址寄存器得到段表首地址, 根据逻辑段号找到该段起始地址, 并且与段内地址拼成物理地址. 可以用快表来实现加速(硬件) \\
	
	存储保护: 保护键(软件)或扩充页表, 增加存取控制项(硬件) \\

\subsection{段页式存储管理}

	主存分配方式: 以段为单位, 为每一个逻辑段按用户程序需求的页数分配, 分配空间不一定连续 \\
	
	硬件地址转换: 需要段表始址寄存器, 长度寄存器和快表 \\
	
	适合系统: 多道处理系统. \\
	
	重定位方式: 动态 \\
	
	地址转换过程: 根据段号查找快表, 如果找到则直接获得物理地址, 否则通过段表始址寄存器查找段表, 根据段号查找页表位置, 根据页号在页表中查找内存块号, 和页内地址拼接成物理地址, 并更新快表(硬件) \\
	
	存储保护: 保护键(软件)或扩充页表, 增加存取控制项(硬件) \\

\subsection{虚拟页式存储管理}

	主存分配方式: 程序运行时不装入全部页面, 根据需求动态装入, 使用页面置换算法来调换内存中的页面 \\
	
	硬件地址转换: 需要在页式基础上增加页号, 驻留位, 内存块号, 外存地址, 访问位, 修改位 \\
	
	适合系统: 多道处理系统. \\
	
	重定位方式: 动态 \\
	
	地址转换过程: 在地址映射过程中如果访问页面不存在则产生缺页中断(硬件), 并根据一定的算法将页面调入内存, 如果内存已满, 需要将某些页面暂时移出内存. (软件) \\
	
	存储保护: 保护键(软件)或扩充页表, 增加存取控制项(硬件) \\

\subsection{虚拟段式存储管理}

	主存分配方式: 程序运行时不全部装入, 根据需求动态装入, 以段为单位进行内外村的交换. \\
	
	硬件地址转换: 需要在段式基础上增加特征位, 存取权限位, 标志位, 扩充位 \\
	
	适合系统: 多道处理系统. \\
	
	重定位方式: 动态 \\
	
	地址转换过程: 在地址映射过程中如果访问段不存在则产生缺段中断(硬件), 检察系统是否有足够连续空间, 如有则直接装入, 否则尝试使用紧缩技术获得足够连续空间, 如果还不足则考虑淘汰一些内存中的不常
用段. (软件) \\
	
	存储保护: 保护键(软件)或扩充页表, 增加存取控制项(硬件) \\

\end{CJK*}
\end{document}