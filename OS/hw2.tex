% homework
% 20161007
% by hiaoxui

\documentclass[a4paper,12pt,notitlepage]{article}

\usepackage{CJKutf8}
\usepackage{indentfirst}

\setlength{\parindent}{2em} 

\begin{CJK*}{UTF8}{gbsn}
\begin{document}

\title{第二次OS作业}
\author{整理:hiaoxui}
\maketitle

\section{什么是中断,中断的作用是什么?中断处理的主要步骤是什么?多个中断同时发生时,系统如何处理?}

	中断CPU对系统中或系统外发生的异步事件作出的响应,(异步事件:无一定时序关系的随机发生的事件),CPU暂停正在执行的程序,保留现场后自动转去执行相应事件的处理程序,处理完成后返回断点,继续执行被打断的程序. \\
	
	所有计算机系统都采用硬件和软件,即硬件中断装置和软件中断处理程序/异常处理程序相结合的方法实现中断/异常处理 \\
	
\begin{enumerate}
	\item 发现中断源
	\begin{itemize}
		\item 在中断未屏蔽的前提下,硬件发现中断/异常事件,并由CPU响应中断/异常请求.
		\item 发现多个中断源时,将根据预定的中断优先级,先后响应中断请求.
	\end{itemize}
	\item 保护现场
	\begin{itemize}
		\item 暂停当前程序运行
		\item 硬件将中断点的现场信息(PSW)保存至核心栈
		\begin{itemize}
			\item 使得中断处理程序/异常处理程序在运行时,不会破坏被中断程序中的有用信息,以便在中断处理结束后返回原程序继续运行
		\end{itemize}
	\end{itemize}
	\item 转向中断/异常事件的处理程序
	\begin{itemize}
		\item 处理器状态已从用户态切换至核心态,中断处理程序/异常处理程序开始工作
	\end{itemize}
	\item 恢复现场
	\begin{itemize}
		\item 当中断处理结束后,恢复PSW,重新返回中断点以便执行后续指令.
		\item 异常处理结束后返回点根据异常类型而异
		\begin{itemize}
			\item 出错保存指向触发异常的那条指令
			\item 陷入保存触发异常的那条指令的下一条指令
		\end{itemize}
	\end{itemize}
\end{enumerate}

	当有多个中断同时发生时,系统根据中断优先级决定响应中断次序,优先响应级别高的中断;对同级中断按硬件规定次序. \\
	
	中断优先级是由硬件规定的,系统根据引起中断事件的重要性与紧迫程度将中断源划分为若干个级别. \\
	
\begin{itemize}
	\item 中断优先级只是表示中断装置响应中断的次序 ,在系统设计是已被确定且不能更改
	\item 操作系统响应中断存在先后次序,中断处理顺序和响应顺序未必一致,即先响应的中断可能滞后处理
\end{itemize}
	
	计算机系统运行中,可能同时出现多个中断,或者前一个中断尚未处理完,接着又发生新的中断.处理方式分为三种: \\
	
\begin{itemize}
	\item 串行处理
	\begin{itemize}
		\item 运行一个中断处理程序时,禁止再次发生中断,通过中断屏蔽实现 \\
		\item 所有中断严格按照顺序串行处理 \\
	\end{itemize}
	\item 即时处理
	\begin{itemize}
		\item 运行中断处理程序时,若出现任何程序性中断事件,表明此时中断处理程序有例外,应对其立即响应并处理
	\end{itemize}
	\item 嵌套处理
	\begin{itemize}
		\item 在处理中断时又响应新的中断
		\item 正当处理一个中断时禁止其它中断,此时系统将对任何新发生的中断置之不理;当处理器允许中断时,新中断再被处理器检测并处理
		\item 允许高优先级的中断打断低优先级的中断处理
	\end{itemize}
\end{itemize}	

\section{什么时候发生系统调用,系统调用的过程是什么?}

	用户程序或其他系统程序通过系统调用就可以访问系统资源,调用操作系统功能,而不必了解操作系统内部结构和硬件细节,它是用户程序或其他系统程序获得操作系统服务的唯一途径. \\
	
	当程序请求操作系统服务时,就会执行一条系统调用.其过程为: \\
	
\begin{enumerate}
	\item 当 CPU 执行访管指令或陷阱指令时,即引起访管中断或陷阱中断
	\item 处理器保存中断点的程序执行上下文环境( PSW,PC 和其他的一些寄存器), CPU 切换到管态
	\item 中断处理程序开始工作,调用相应的系统服务
	\item 中断处理结束后,恢复被中断程序的上下文环境,CPU 恢复为目态,回到中断点继续执行
\end{enumerate}

\section{什么是存储保护?有何作用?操作系统与硬件如何配合来实现存储保护?}

	存储保护就是在多用户,多任务操作系统中,OS给每个运行进程分配一个存储区域.其目的是多个程序同时在同一台机器上运行,保证互不侵犯,防止一个用户程序破坏其他用户程序,也防止用户程序互相干扰. \\
	
	存储保护机构是界地址寄存器,在CPU中设置一对界限寄存器来存放该用户作业在主存中的下限和上限地址,分别称为下限寄存器和上限寄存器(或一个寄存器作为基址寄存器,另一作为限长寄存器来指出程序在内存的存放区域).每当CPU访问主存时,硬件自动将被访问的主存地址与界限寄存器的内容进行比较,判断是否越界. \\
	
	每个存储块有一个与其相关的二进位组成的存储保护键,当用户作业进入主存时,操作系统分配给它一个唯一的、不与其它作业相同的存储键号,并分配给该作业的各存储块的存储键设为同样的键号.操作系统挑上次作业在CPU运行时,操作系统同时将该作业的存储键号放在程序状态字PSW的存储键域中.每当CPU访问主存时,都将对主存的存储键与PSW中的存储键域进行比较. \\
	
	这样OS就和硬件相配合,完成了存储保护. \\
	
\section{常用的I/O控制技术有哪些?各有什么特点?}

\begin{itemize}
	\item I/O结构,通道.
	\begin{itemize}
		\item 独立于处理器,专门负责数据I/O传输工作的处理单元.
		\item 为了使CPU从I/O事务中解脱出来,同时为了提高CPU与设备、设备与设备之间的并行度 
		\item 独立于CPU的专门负责数据输入/输出传输工作的处理机,对外部设备实现统一管理,代替CPU对输入/输出操作进行控制,从而使输入/输出操作可和CPU并行操作
	\end{itemize}
	\item DMA
	\begin{itemize}
		\item 通过系统总线中的一个独立控制单元—DMA控制器,自动控制成块数据在内存和I/O单元之间的传送
		\item 工作机制
		\begin{itemize}
			\item 处理器读写一整块数据时,向DMA控制单元发送一条命令即可,处理器处理其他事情
			\item DMA控制器将自动管理整块数据的传送
			\item 传送完毕后,给处理器发一个结束中断
		\end{itemize}
		\item DMA技术可以大大提高处理I/O的效能
	\end{itemize}
	\item 缓冲技术
	\begin{itemize}
		\item 在外部设备与其它硬件部件之间的数据缓存技术,利用存储器件在外部设备中设置了数据的一个存储区域
		\item 用户从工作区向设备输出或从设备向工作区输入时,导致工
作区长期占用
		\item 减少输入输出,减轻对通道和输入输出设备压力
		\item 缓冲区信息可以由多个用户共享
		\item 解决了CPU处理数据速度与设备传输速度不相匹配的问题
	\end{itemize}
\end{itemize}
	
\section{为什么要采用缓冲技术?常用的缓冲技术有哪些?它是如何工作的?}

	CPU处理速度与设备传输数据速度不相匹配,采用缓冲区缓解矛盾. \\
	
\begin{itemize}
	\item 多缓冲区技术
	\begin{itemize}
		\item Cache:离CPU最近,使CPU快速访问常使用的数据
		\item CPU首先到一级Cache中找
		\item 如果没有,CPU到二级Cache中找
		\item 如果没有,CPU到系统内存中找
	\end{itemize}
	\item 处理器与主存储器之间的缓冲技术
	\item 处理器和其他外部设备之间的缓冲技术
	\item 设备与设备之间的通信的缓冲技术
\end{itemize}

\section{查询相关资料,以某一类操作系统的中断系统为例(Windows、Linux等),说明其工作原理}

	以linux的中断为例,讨论其工作原理. \\
	
	我们期望让中断处理程序运行得快,并想让它完成的工作量多,这两个目标相互制约,如何解决——上下半部机制. \\

	我们把中断处理切为两半.中断处理程序是上半部——接受中断,他就立即开始执行,但只有做严格时限的工作.能够被允许稍后完成的工作会推迟到下半部去,此后,在合适的时机,下半部会被开终端执行.上半部简单快速,执行时禁止一些或者全部中断.下半部稍后执行,而且执行期间可以响应所有的中断.这种设计可以使系统处于中断屏蔽状态的时间尽可能的短,以此来提高系统的响应能力.上半部只有中断处理程序机制,而下半部的实现有软中断实现,tasklet实现和工作队列实现. \\

	我们用网卡来解释一下这两半.当网卡接受到数据包时,通知内核,触发中断,所谓的上半部就是,及时读取数据包到内存,防止因为延迟导致丢失,这是很急迫的工作.读到内存后,对这些数据的处理不再紧迫,此时内核可以去执行中断前运行的程序,而对网络数据包的处理则交给下半部处理. \\

	\textbf{上下半部划分原则} \\
	
\begin{enumerate}
	\item 如果一个任务对时间非常敏感,将其放在中断处理程序中执行
	\item 如果一个任务和硬件有关,将其放在中断处理程序中执行
	\item 如果一个任务要保证不被其他中断打断,将其放在中断处理程序中执行
	\item 其他所有任务,考虑放置在下半部执行
\end{enumerate}
	
	\textbf{下半部实现机制之软中断} \\

	软中断作为下半部机制的代表,是随着SMP（share memoryprocessor）的出现应运而生的,它也是tasklet实现的基础（tasklet实际上只是在软中断的基础上添加了一定的机制）.软中断一般是“可延迟函数”的总称,有时候也包括了tasklet（请读者在遇到的时候根据上下文推断是否包含tasklet）.它的出现就是因为要满足上面所提出的上半部和下半部的区别,使得对时间不敏感的任务延后执行,软中断执行中断处理程序留给它去完成的剩余任务,而且可以在多个CPU上并行执行,使得总的系统效率可以更高.它的特性包括： \\
	
\begin{enumerate}
	\item 产生后并不是马上可以执行,必须要等待内核的调度才能执行.软中断不能被自己打断,只能被硬件中断打断（上半部）.
	\item 可以并发运行在多个CPU上（即使同一类型的也可以）.所以软中断必须设计为可重入的函数（允许多个CPU同时操作）,因此也需要使用自旋锁来保护其数据结构.
\end{enumerate}
 
	\textbf{下半部实现机制之tasklet} \\

	tasklet是通过软中断实现的,所以它本身也是软中断. \\

	软中断用轮询的方式处理.假如正好是最后一种中断,则必须循环完所有的中断类型,才能最终执行对应的处理函数.显然当年开发人员为了保证轮询的效率,于是限制中断个数为32个. \\

	为了提高中断处理数量,顺道改进处理效率,于是产生了tasklet机制. \\

	Tasklet采用无差别的队列机制,有中断时才执行,免去了循环查表之苦.Tasklet作为一种新机制,显然可以承担更多的优点.正好这时候SMP越来越火了,因此又在tasklet中加入了SMP机制,保证同种中断只能在一个cpu上执行.在软中断时代,显然没有这种考虑.因此同一种软中断可以在两个cpu上同时执行,很可能造成冲突. \\

	总结下tasklet的优点：

\begin{enumerate}
	\item 无类型数量限制
	\item 效率高,无需循环查表
	\item 	支持SMP机制
\end{enumerate}
	
	它的特性如下： 

\begin{enumerate}
	\item 一种特定类型的tasklet只能运行在一个CPU上,不能并行,只能串行执行.
	\item 多个不同类型的tasklet可以并行在多个CPU上.
	\item 软中断是静态分配的,在内核编译好之后,就不能改变.但tasklet就灵活许多,可以在运行时改变（比如添加模块时）.
\end{enumerate}

	\textbf{下半部实现机制之工作队列（work queue）} \\

	上面我们介绍的可延迟函数运行在中断上下文中（软中断的一个检查点就是do\_  IRQ退出的时候）,于是导致了一些问题：软中断不能睡眠、不能阻塞.由于中断上下文出于内核态,没有进程切换,所以如果软中断一旦睡眠或者阻塞,将无法退出这种状态,导致内核会整个僵死.但可阻塞函数不能用在中断上下文中实现,必须要运行在进程上下文中,例如访问磁盘数据块的函数.因此,可阻塞函数不能用软中断来实现.但是它们往往又具有可延迟的特性. \\

	上面我们介绍的可延迟函数运行在中断上下文中,于是导致了一些问题,说明它们不可挂起,也就是说软中断不能睡眠、不能阻塞,原因是由于中断上下文出于内核态,没有进程切换,所以如果软中断一旦睡眠或者阻塞,将无法退出这种状态,导致内核会整个僵死.因此,可阻塞函数不能用软中断来实现.但是它们往往又具有可延迟的特性.而且由于是串行执行,因此只要有一个处理时间较长,则会导致其他中断响应的延迟.为了完成这些不可能完成的任务,于是出现了工作队列,它能够在不同的进程间切换,以完成不同的工作. \\

	如果推后执行的任务需要睡眠,那么就选择工作队列,如果不需要睡眠,那么就选择软中断或tasklet.工作队列能运行在进程上下文,它将工作托付给一个内核线程.工作队列说白了就是一组内核线程,作为中断守护线程来使用.多个中断可以放在一个线程中,也可以每个中断分配一个线程.我们用结构体workqueue\_ struct表示工作者线程,工作者线程是用内核线程实现的.而工作者线程是如何执行被推后的工作——有这样一个链表,它由结构体work\_ struct组成,而这个work\_ struct则描述了一个工作,一旦这个工作被执行完,相应的work\_ struct对象就从链表上移去,当链表上不再有对象时,工作者线程就会继续休眠.因为工作队列是线程,所以我们可以使用所有可以在线程中使用的方法. \\

	\textbf{Linux软中断和工作队列的作用是什么} \\

	Linux中的软中断和工作队列是中断上下部机制中的下半部实现机制. 
	
\begin{enumerate}
	\item 软中断一般是“可延迟函数”的总称,它不能睡眠,不能阻塞,它处于中断上下文,不能进城切换,软中断不能被自己打断,只能被硬件中断打断（上半部）,可以并发的运行在多个CPU上.所以软中断必须设计成可重入的函数,因此也需要自旋锁来保护其数据结构.
	\item 工作队列中的函数处在进程上下文中,它可以睡眠,也能被阻塞,能够在不同的进程间切换,以完成不同的工作.
\end{enumerate}

	可延迟函数和工作队列都不能访问用户的进程空间,可延时函数在执行时不可能有任何正在运行的进程,工作队列的函数有内核进程执行,他不能访问用户空间地址. \\

\end{CJK*}
\end{document}